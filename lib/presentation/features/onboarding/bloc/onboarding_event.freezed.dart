// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'onboarding_event.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$OnboardingEvent {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is OnboardingEvent);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'OnboardingEvent()';
}


}

/// @nodoc
class $OnboardingEventCopyWith<$Res>  {
$OnboardingEventCopyWith(OnboardingEvent _, $Res Function(OnboardingEvent) __);
}


/// Adds pattern-matching-related methods to [OnboardingEvent].
extension OnboardingEventPatterns on OnboardingEvent {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( LoadDogBreeds value)?  loadDogBreeds,TResult Function( LoadOnboardingData value)?  loadOnboardingData,TResult Function( UpdateBreed value)?  updateBreed,TResult Function( UpdateDogName value)?  updateDogName,TResult Function( UpdateGender value)?  updateGender,TResult Function( UpdateSterilization value)?  updateSterilization,TResult Function( UpdateBirthDate value)?  updateBirthDate,TResult Function( UpdateWeightShape value)?  updateWeightShape,TResult Function( UpdateWeightValue value)?  updateWeightValue,TResult Function( UpdateActivityLevel value)?  updateActivityLevel,TResult Function( UpdateHasPathologies value)?  updateHasPathologies,TResult Function( UpdateFoodProfile value)?  updateFoodProfile,required TResult orElse(),}){
final _that = this;
switch (_that) {
case LoadDogBreeds() when loadDogBreeds != null:
return loadDogBreeds(_that);case LoadOnboardingData() when loadOnboardingData != null:
return loadOnboardingData(_that);case UpdateBreed() when updateBreed != null:
return updateBreed(_that);case UpdateDogName() when updateDogName != null:
return updateDogName(_that);case UpdateGender() when updateGender != null:
return updateGender(_that);case UpdateSterilization() when updateSterilization != null:
return updateSterilization(_that);case UpdateBirthDate() when updateBirthDate != null:
return updateBirthDate(_that);case UpdateWeightShape() when updateWeightShape != null:
return updateWeightShape(_that);case UpdateWeightValue() when updateWeightValue != null:
return updateWeightValue(_that);case UpdateActivityLevel() when updateActivityLevel != null:
return updateActivityLevel(_that);case UpdateHasPathologies() when updateHasPathologies != null:
return updateHasPathologies(_that);case UpdateFoodProfile() when updateFoodProfile != null:
return updateFoodProfile(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( LoadDogBreeds value)  loadDogBreeds,required TResult Function( LoadOnboardingData value)  loadOnboardingData,required TResult Function( UpdateBreed value)  updateBreed,required TResult Function( UpdateDogName value)  updateDogName,required TResult Function( UpdateGender value)  updateGender,required TResult Function( UpdateSterilization value)  updateSterilization,required TResult Function( UpdateBirthDate value)  updateBirthDate,required TResult Function( UpdateWeightShape value)  updateWeightShape,required TResult Function( UpdateWeightValue value)  updateWeightValue,required TResult Function( UpdateActivityLevel value)  updateActivityLevel,required TResult Function( UpdateHasPathologies value)  updateHasPathologies,required TResult Function( UpdateFoodProfile value)  updateFoodProfile,}){
final _that = this;
switch (_that) {
case LoadDogBreeds():
return loadDogBreeds(_that);case LoadOnboardingData():
return loadOnboardingData(_that);case UpdateBreed():
return updateBreed(_that);case UpdateDogName():
return updateDogName(_that);case UpdateGender():
return updateGender(_that);case UpdateSterilization():
return updateSterilization(_that);case UpdateBirthDate():
return updateBirthDate(_that);case UpdateWeightShape():
return updateWeightShape(_that);case UpdateWeightValue():
return updateWeightValue(_that);case UpdateActivityLevel():
return updateActivityLevel(_that);case UpdateHasPathologies():
return updateHasPathologies(_that);case UpdateFoodProfile():
return updateFoodProfile(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( LoadDogBreeds value)?  loadDogBreeds,TResult? Function( LoadOnboardingData value)?  loadOnboardingData,TResult? Function( UpdateBreed value)?  updateBreed,TResult? Function( UpdateDogName value)?  updateDogName,TResult? Function( UpdateGender value)?  updateGender,TResult? Function( UpdateSterilization value)?  updateSterilization,TResult? Function( UpdateBirthDate value)?  updateBirthDate,TResult? Function( UpdateWeightShape value)?  updateWeightShape,TResult? Function( UpdateWeightValue value)?  updateWeightValue,TResult? Function( UpdateActivityLevel value)?  updateActivityLevel,TResult? Function( UpdateHasPathologies value)?  updateHasPathologies,TResult? Function( UpdateFoodProfile value)?  updateFoodProfile,}){
final _that = this;
switch (_that) {
case LoadDogBreeds() when loadDogBreeds != null:
return loadDogBreeds(_that);case LoadOnboardingData() when loadOnboardingData != null:
return loadOnboardingData(_that);case UpdateBreed() when updateBreed != null:
return updateBreed(_that);case UpdateDogName() when updateDogName != null:
return updateDogName(_that);case UpdateGender() when updateGender != null:
return updateGender(_that);case UpdateSterilization() when updateSterilization != null:
return updateSterilization(_that);case UpdateBirthDate() when updateBirthDate != null:
return updateBirthDate(_that);case UpdateWeightShape() when updateWeightShape != null:
return updateWeightShape(_that);case UpdateWeightValue() when updateWeightValue != null:
return updateWeightValue(_that);case UpdateActivityLevel() when updateActivityLevel != null:
return updateActivityLevel(_that);case UpdateHasPathologies() when updateHasPathologies != null:
return updateHasPathologies(_that);case UpdateFoodProfile() when updateFoodProfile != null:
return updateFoodProfile(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  loadDogBreeds,TResult Function()?  loadOnboardingData,TResult Function( int breedId)?  updateBreed,TResult Function( String dogName)?  updateDogName,TResult Function( String gender)?  updateGender,TResult Function( bool isSterilized)?  updateSterilization,TResult Function( DateTime birthDate)?  updateBirthDate,TResult Function( WeightShapeType weightShape)?  updateWeightShape,TResult Function( double value)?  updateWeightValue,TResult Function( ActivityLevelType activityLevel)?  updateActivityLevel,TResult Function( bool hasPathologies)?  updateHasPathologies,TResult Function( FoodProfileType foodProfile)?  updateFoodProfile,required TResult orElse(),}) {final _that = this;
switch (_that) {
case LoadDogBreeds() when loadDogBreeds != null:
return loadDogBreeds();case LoadOnboardingData() when loadOnboardingData != null:
return loadOnboardingData();case UpdateBreed() when updateBreed != null:
return updateBreed(_that.breedId);case UpdateDogName() when updateDogName != null:
return updateDogName(_that.dogName);case UpdateGender() when updateGender != null:
return updateGender(_that.gender);case UpdateSterilization() when updateSterilization != null:
return updateSterilization(_that.isSterilized);case UpdateBirthDate() when updateBirthDate != null:
return updateBirthDate(_that.birthDate);case UpdateWeightShape() when updateWeightShape != null:
return updateWeightShape(_that.weightShape);case UpdateWeightValue() when updateWeightValue != null:
return updateWeightValue(_that.value);case UpdateActivityLevel() when updateActivityLevel != null:
return updateActivityLevel(_that.activityLevel);case UpdateHasPathologies() when updateHasPathologies != null:
return updateHasPathologies(_that.hasPathologies);case UpdateFoodProfile() when updateFoodProfile != null:
return updateFoodProfile(_that.foodProfile);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  loadDogBreeds,required TResult Function()  loadOnboardingData,required TResult Function( int breedId)  updateBreed,required TResult Function( String dogName)  updateDogName,required TResult Function( String gender)  updateGender,required TResult Function( bool isSterilized)  updateSterilization,required TResult Function( DateTime birthDate)  updateBirthDate,required TResult Function( WeightShapeType weightShape)  updateWeightShape,required TResult Function( double value)  updateWeightValue,required TResult Function( ActivityLevelType activityLevel)  updateActivityLevel,required TResult Function( bool hasPathologies)  updateHasPathologies,required TResult Function( FoodProfileType foodProfile)  updateFoodProfile,}) {final _that = this;
switch (_that) {
case LoadDogBreeds():
return loadDogBreeds();case LoadOnboardingData():
return loadOnboardingData();case UpdateBreed():
return updateBreed(_that.breedId);case UpdateDogName():
return updateDogName(_that.dogName);case UpdateGender():
return updateGender(_that.gender);case UpdateSterilization():
return updateSterilization(_that.isSterilized);case UpdateBirthDate():
return updateBirthDate(_that.birthDate);case UpdateWeightShape():
return updateWeightShape(_that.weightShape);case UpdateWeightValue():
return updateWeightValue(_that.value);case UpdateActivityLevel():
return updateActivityLevel(_that.activityLevel);case UpdateHasPathologies():
return updateHasPathologies(_that.hasPathologies);case UpdateFoodProfile():
return updateFoodProfile(_that.foodProfile);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  loadDogBreeds,TResult? Function()?  loadOnboardingData,TResult? Function( int breedId)?  updateBreed,TResult? Function( String dogName)?  updateDogName,TResult? Function( String gender)?  updateGender,TResult? Function( bool isSterilized)?  updateSterilization,TResult? Function( DateTime birthDate)?  updateBirthDate,TResult? Function( WeightShapeType weightShape)?  updateWeightShape,TResult? Function( double value)?  updateWeightValue,TResult? Function( ActivityLevelType activityLevel)?  updateActivityLevel,TResult? Function( bool hasPathologies)?  updateHasPathologies,TResult? Function( FoodProfileType foodProfile)?  updateFoodProfile,}) {final _that = this;
switch (_that) {
case LoadDogBreeds() when loadDogBreeds != null:
return loadDogBreeds();case LoadOnboardingData() when loadOnboardingData != null:
return loadOnboardingData();case UpdateBreed() when updateBreed != null:
return updateBreed(_that.breedId);case UpdateDogName() when updateDogName != null:
return updateDogName(_that.dogName);case UpdateGender() when updateGender != null:
return updateGender(_that.gender);case UpdateSterilization() when updateSterilization != null:
return updateSterilization(_that.isSterilized);case UpdateBirthDate() when updateBirthDate != null:
return updateBirthDate(_that.birthDate);case UpdateWeightShape() when updateWeightShape != null:
return updateWeightShape(_that.weightShape);case UpdateWeightValue() when updateWeightValue != null:
return updateWeightValue(_that.value);case UpdateActivityLevel() when updateActivityLevel != null:
return updateActivityLevel(_that.activityLevel);case UpdateHasPathologies() when updateHasPathologies != null:
return updateHasPathologies(_that.hasPathologies);case UpdateFoodProfile() when updateFoodProfile != null:
return updateFoodProfile(_that.foodProfile);case _:
  return null;

}
}

}

/// @nodoc


class LoadDogBreeds implements OnboardingEvent {
  const LoadDogBreeds();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LoadDogBreeds);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'OnboardingEvent.loadDogBreeds()';
}


}




/// @nodoc


class LoadOnboardingData implements OnboardingEvent {
  const LoadOnboardingData();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LoadOnboardingData);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'OnboardingEvent.loadOnboardingData()';
}


}




/// @nodoc


class UpdateBreed implements OnboardingEvent {
  const UpdateBreed(this.breedId);
  

 final  int breedId;

/// Create a copy of OnboardingEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UpdateBreedCopyWith<UpdateBreed> get copyWith => _$UpdateBreedCopyWithImpl<UpdateBreed>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UpdateBreed&&(identical(other.breedId, breedId) || other.breedId == breedId));
}


@override
int get hashCode => Object.hash(runtimeType,breedId);

@override
String toString() {
  return 'OnboardingEvent.updateBreed(breedId: $breedId)';
}


}

/// @nodoc
abstract mixin class $UpdateBreedCopyWith<$Res> implements $OnboardingEventCopyWith<$Res> {
  factory $UpdateBreedCopyWith(UpdateBreed value, $Res Function(UpdateBreed) _then) = _$UpdateBreedCopyWithImpl;
@useResult
$Res call({
 int breedId
});




}
/// @nodoc
class _$UpdateBreedCopyWithImpl<$Res>
    implements $UpdateBreedCopyWith<$Res> {
  _$UpdateBreedCopyWithImpl(this._self, this._then);

  final UpdateBreed _self;
  final $Res Function(UpdateBreed) _then;

/// Create a copy of OnboardingEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? breedId = null,}) {
  return _then(UpdateBreed(
null == breedId ? _self.breedId : breedId // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}

/// @nodoc


class UpdateDogName implements OnboardingEvent {
  const UpdateDogName(this.dogName);
  

 final  String dogName;

/// Create a copy of OnboardingEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UpdateDogNameCopyWith<UpdateDogName> get copyWith => _$UpdateDogNameCopyWithImpl<UpdateDogName>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UpdateDogName&&(identical(other.dogName, dogName) || other.dogName == dogName));
}


@override
int get hashCode => Object.hash(runtimeType,dogName);

@override
String toString() {
  return 'OnboardingEvent.updateDogName(dogName: $dogName)';
}


}

/// @nodoc
abstract mixin class $UpdateDogNameCopyWith<$Res> implements $OnboardingEventCopyWith<$Res> {
  factory $UpdateDogNameCopyWith(UpdateDogName value, $Res Function(UpdateDogName) _then) = _$UpdateDogNameCopyWithImpl;
@useResult
$Res call({
 String dogName
});




}
/// @nodoc
class _$UpdateDogNameCopyWithImpl<$Res>
    implements $UpdateDogNameCopyWith<$Res> {
  _$UpdateDogNameCopyWithImpl(this._self, this._then);

  final UpdateDogName _self;
  final $Res Function(UpdateDogName) _then;

/// Create a copy of OnboardingEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? dogName = null,}) {
  return _then(UpdateDogName(
null == dogName ? _self.dogName : dogName // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class UpdateGender implements OnboardingEvent {
  const UpdateGender(this.gender);
  

 final  String gender;

/// Create a copy of OnboardingEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UpdateGenderCopyWith<UpdateGender> get copyWith => _$UpdateGenderCopyWithImpl<UpdateGender>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UpdateGender&&(identical(other.gender, gender) || other.gender == gender));
}


@override
int get hashCode => Object.hash(runtimeType,gender);

@override
String toString() {
  return 'OnboardingEvent.updateGender(gender: $gender)';
}


}

/// @nodoc
abstract mixin class $UpdateGenderCopyWith<$Res> implements $OnboardingEventCopyWith<$Res> {
  factory $UpdateGenderCopyWith(UpdateGender value, $Res Function(UpdateGender) _then) = _$UpdateGenderCopyWithImpl;
@useResult
$Res call({
 String gender
});




}
/// @nodoc
class _$UpdateGenderCopyWithImpl<$Res>
    implements $UpdateGenderCopyWith<$Res> {
  _$UpdateGenderCopyWithImpl(this._self, this._then);

  final UpdateGender _self;
  final $Res Function(UpdateGender) _then;

/// Create a copy of OnboardingEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? gender = null,}) {
  return _then(UpdateGender(
null == gender ? _self.gender : gender // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class UpdateSterilization implements OnboardingEvent {
  const UpdateSterilization(this.isSterilized);
  

 final  bool isSterilized;

/// Create a copy of OnboardingEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UpdateSterilizationCopyWith<UpdateSterilization> get copyWith => _$UpdateSterilizationCopyWithImpl<UpdateSterilization>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UpdateSterilization&&(identical(other.isSterilized, isSterilized) || other.isSterilized == isSterilized));
}


@override
int get hashCode => Object.hash(runtimeType,isSterilized);

@override
String toString() {
  return 'OnboardingEvent.updateSterilization(isSterilized: $isSterilized)';
}


}

/// @nodoc
abstract mixin class $UpdateSterilizationCopyWith<$Res> implements $OnboardingEventCopyWith<$Res> {
  factory $UpdateSterilizationCopyWith(UpdateSterilization value, $Res Function(UpdateSterilization) _then) = _$UpdateSterilizationCopyWithImpl;
@useResult
$Res call({
 bool isSterilized
});




}
/// @nodoc
class _$UpdateSterilizationCopyWithImpl<$Res>
    implements $UpdateSterilizationCopyWith<$Res> {
  _$UpdateSterilizationCopyWithImpl(this._self, this._then);

  final UpdateSterilization _self;
  final $Res Function(UpdateSterilization) _then;

/// Create a copy of OnboardingEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? isSterilized = null,}) {
  return _then(UpdateSterilization(
null == isSterilized ? _self.isSterilized : isSterilized // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}


}

/// @nodoc


class UpdateBirthDate implements OnboardingEvent {
  const UpdateBirthDate(this.birthDate);
  

 final  DateTime birthDate;

/// Create a copy of OnboardingEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UpdateBirthDateCopyWith<UpdateBirthDate> get copyWith => _$UpdateBirthDateCopyWithImpl<UpdateBirthDate>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UpdateBirthDate&&(identical(other.birthDate, birthDate) || other.birthDate == birthDate));
}


@override
int get hashCode => Object.hash(runtimeType,birthDate);

@override
String toString() {
  return 'OnboardingEvent.updateBirthDate(birthDate: $birthDate)';
}


}

/// @nodoc
abstract mixin class $UpdateBirthDateCopyWith<$Res> implements $OnboardingEventCopyWith<$Res> {
  factory $UpdateBirthDateCopyWith(UpdateBirthDate value, $Res Function(UpdateBirthDate) _then) = _$UpdateBirthDateCopyWithImpl;
@useResult
$Res call({
 DateTime birthDate
});




}
/// @nodoc
class _$UpdateBirthDateCopyWithImpl<$Res>
    implements $UpdateBirthDateCopyWith<$Res> {
  _$UpdateBirthDateCopyWithImpl(this._self, this._then);

  final UpdateBirthDate _self;
  final $Res Function(UpdateBirthDate) _then;

/// Create a copy of OnboardingEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? birthDate = null,}) {
  return _then(UpdateBirthDate(
null == birthDate ? _self.birthDate : birthDate // ignore: cast_nullable_to_non_nullable
as DateTime,
  ));
}


}

/// @nodoc


class UpdateWeightShape implements OnboardingEvent {
  const UpdateWeightShape(this.weightShape);
  

 final  WeightShapeType weightShape;

/// Create a copy of OnboardingEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UpdateWeightShapeCopyWith<UpdateWeightShape> get copyWith => _$UpdateWeightShapeCopyWithImpl<UpdateWeightShape>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UpdateWeightShape&&(identical(other.weightShape, weightShape) || other.weightShape == weightShape));
}


@override
int get hashCode => Object.hash(runtimeType,weightShape);

@override
String toString() {
  return 'OnboardingEvent.updateWeightShape(weightShape: $weightShape)';
}


}

/// @nodoc
abstract mixin class $UpdateWeightShapeCopyWith<$Res> implements $OnboardingEventCopyWith<$Res> {
  factory $UpdateWeightShapeCopyWith(UpdateWeightShape value, $Res Function(UpdateWeightShape) _then) = _$UpdateWeightShapeCopyWithImpl;
@useResult
$Res call({
 WeightShapeType weightShape
});




}
/// @nodoc
class _$UpdateWeightShapeCopyWithImpl<$Res>
    implements $UpdateWeightShapeCopyWith<$Res> {
  _$UpdateWeightShapeCopyWithImpl(this._self, this._then);

  final UpdateWeightShape _self;
  final $Res Function(UpdateWeightShape) _then;

/// Create a copy of OnboardingEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? weightShape = null,}) {
  return _then(UpdateWeightShape(
null == weightShape ? _self.weightShape : weightShape // ignore: cast_nullable_to_non_nullable
as WeightShapeType,
  ));
}


}

/// @nodoc


class UpdateWeightValue implements OnboardingEvent {
  const UpdateWeightValue(this.value);
  

 final  double value;

/// Create a copy of OnboardingEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UpdateWeightValueCopyWith<UpdateWeightValue> get copyWith => _$UpdateWeightValueCopyWithImpl<UpdateWeightValue>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UpdateWeightValue&&(identical(other.value, value) || other.value == value));
}


@override
int get hashCode => Object.hash(runtimeType,value);

@override
String toString() {
  return 'OnboardingEvent.updateWeightValue(value: $value)';
}


}

/// @nodoc
abstract mixin class $UpdateWeightValueCopyWith<$Res> implements $OnboardingEventCopyWith<$Res> {
  factory $UpdateWeightValueCopyWith(UpdateWeightValue value, $Res Function(UpdateWeightValue) _then) = _$UpdateWeightValueCopyWithImpl;
@useResult
$Res call({
 double value
});




}
/// @nodoc
class _$UpdateWeightValueCopyWithImpl<$Res>
    implements $UpdateWeightValueCopyWith<$Res> {
  _$UpdateWeightValueCopyWithImpl(this._self, this._then);

  final UpdateWeightValue _self;
  final $Res Function(UpdateWeightValue) _then;

/// Create a copy of OnboardingEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? value = null,}) {
  return _then(UpdateWeightValue(
null == value ? _self.value : value // ignore: cast_nullable_to_non_nullable
as double,
  ));
}


}

/// @nodoc


class UpdateActivityLevel implements OnboardingEvent {
  const UpdateActivityLevel(this.activityLevel);
  

 final  ActivityLevelType activityLevel;

/// Create a copy of OnboardingEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UpdateActivityLevelCopyWith<UpdateActivityLevel> get copyWith => _$UpdateActivityLevelCopyWithImpl<UpdateActivityLevel>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UpdateActivityLevel&&(identical(other.activityLevel, activityLevel) || other.activityLevel == activityLevel));
}


@override
int get hashCode => Object.hash(runtimeType,activityLevel);

@override
String toString() {
  return 'OnboardingEvent.updateActivityLevel(activityLevel: $activityLevel)';
}


}

/// @nodoc
abstract mixin class $UpdateActivityLevelCopyWith<$Res> implements $OnboardingEventCopyWith<$Res> {
  factory $UpdateActivityLevelCopyWith(UpdateActivityLevel value, $Res Function(UpdateActivityLevel) _then) = _$UpdateActivityLevelCopyWithImpl;
@useResult
$Res call({
 ActivityLevelType activityLevel
});




}
/// @nodoc
class _$UpdateActivityLevelCopyWithImpl<$Res>
    implements $UpdateActivityLevelCopyWith<$Res> {
  _$UpdateActivityLevelCopyWithImpl(this._self, this._then);

  final UpdateActivityLevel _self;
  final $Res Function(UpdateActivityLevel) _then;

/// Create a copy of OnboardingEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? activityLevel = null,}) {
  return _then(UpdateActivityLevel(
null == activityLevel ? _self.activityLevel : activityLevel // ignore: cast_nullable_to_non_nullable
as ActivityLevelType,
  ));
}


}

/// @nodoc


class UpdateHasPathologies implements OnboardingEvent {
  const UpdateHasPathologies(this.hasPathologies);
  

 final  bool hasPathologies;

/// Create a copy of OnboardingEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UpdateHasPathologiesCopyWith<UpdateHasPathologies> get copyWith => _$UpdateHasPathologiesCopyWithImpl<UpdateHasPathologies>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UpdateHasPathologies&&(identical(other.hasPathologies, hasPathologies) || other.hasPathologies == hasPathologies));
}


@override
int get hashCode => Object.hash(runtimeType,hasPathologies);

@override
String toString() {
  return 'OnboardingEvent.updateHasPathologies(hasPathologies: $hasPathologies)';
}


}

/// @nodoc
abstract mixin class $UpdateHasPathologiesCopyWith<$Res> implements $OnboardingEventCopyWith<$Res> {
  factory $UpdateHasPathologiesCopyWith(UpdateHasPathologies value, $Res Function(UpdateHasPathologies) _then) = _$UpdateHasPathologiesCopyWithImpl;
@useResult
$Res call({
 bool hasPathologies
});




}
/// @nodoc
class _$UpdateHasPathologiesCopyWithImpl<$Res>
    implements $UpdateHasPathologiesCopyWith<$Res> {
  _$UpdateHasPathologiesCopyWithImpl(this._self, this._then);

  final UpdateHasPathologies _self;
  final $Res Function(UpdateHasPathologies) _then;

/// Create a copy of OnboardingEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? hasPathologies = null,}) {
  return _then(UpdateHasPathologies(
null == hasPathologies ? _self.hasPathologies : hasPathologies // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}


}

/// @nodoc


class UpdateFoodProfile implements OnboardingEvent {
  const UpdateFoodProfile(this.foodProfile);
  

 final  FoodProfileType foodProfile;

/// Create a copy of OnboardingEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UpdateFoodProfileCopyWith<UpdateFoodProfile> get copyWith => _$UpdateFoodProfileCopyWithImpl<UpdateFoodProfile>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UpdateFoodProfile&&(identical(other.foodProfile, foodProfile) || other.foodProfile == foodProfile));
}


@override
int get hashCode => Object.hash(runtimeType,foodProfile);

@override
String toString() {
  return 'OnboardingEvent.updateFoodProfile(foodProfile: $foodProfile)';
}


}

/// @nodoc
abstract mixin class $UpdateFoodProfileCopyWith<$Res> implements $OnboardingEventCopyWith<$Res> {
  factory $UpdateFoodProfileCopyWith(UpdateFoodProfile value, $Res Function(UpdateFoodProfile) _then) = _$UpdateFoodProfileCopyWithImpl;
@useResult
$Res call({
 FoodProfileType foodProfile
});




}
/// @nodoc
class _$UpdateFoodProfileCopyWithImpl<$Res>
    implements $UpdateFoodProfileCopyWith<$Res> {
  _$UpdateFoodProfileCopyWithImpl(this._self, this._then);

  final UpdateFoodProfile _self;
  final $Res Function(UpdateFoodProfile) _then;

/// Create a copy of OnboardingEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? foodProfile = null,}) {
  return _then(UpdateFoodProfile(
null == foodProfile ? _self.foodProfile : foodProfile // ignore: cast_nullable_to_non_nullable
as FoodProfileType,
  ));
}


}

// dart format on
